// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'word_meaning_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

WordMeaningModel _$WordMeaningModelFromJson(Map<String, dynamic> json) {
  return _WordMeaningModel.fromJson(json);
}

/// @nodoc
mixin _$WordMeaningModel {
  @JsonKey(name: 'definition')
  String? get definition => throw _privateConstructorUsedError;
  @JsonKey(name: 'partOfSpeech')
  String? get partOfSpeech => throw _privateConstructorUsedError;
  @JsonKey(name: 'synonyms')
  List<String>? get synonyms => throw _privateConstructorUsedError;
  @JsonKey(name: 'antonyms')
  List<String>? get antonyms => throw _privateConstructorUsedError;
  @JsonKey(name: 'typeOf')
  List<String>? get typeOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'derivation')
  List<String>? get derivation => throw _privateConstructorUsedError;
  @JsonKey(name: 'pertainsTo')
  List<String>? get pertainsTo => throw _privateConstructorUsedError;
  @JsonKey(name: 'regionOf')
  List<String>? get regionOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'inRegion')
  List<String>? get inRegion => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasUsages')
  List<String>? get hasUsages => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasCategories')
  List<String>? get hasCategories => throw _privateConstructorUsedError;
  @JsonKey(name: 'inCategory')
  List<String>? get inCategory => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasSubstances')
  List<String>? get hasSubstances => throw _privateConstructorUsedError;
  @JsonKey(name: 'substanceOf')
  List<String>? get substanceOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasMembers')
  List<String>? get hasMembers => throw _privateConstructorUsedError;
  @JsonKey(name: 'memberOf')
  List<String>? get memberOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'entails')
  List<String>? get entails => throw _privateConstructorUsedError;
  @JsonKey(name: 'also')
  List<String>? get also => throw _privateConstructorUsedError;
  @JsonKey(name: 'similarTo')
  List<String>? get similarTo => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasInstances')
  List<String>? get hasInstances => throw _privateConstructorUsedError;
  @JsonKey(name: 'instanceOf')
  List<String>? get instanceOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasParts')
  List<String>? get hasParts => throw _privateConstructorUsedError;
  @JsonKey(name: 'partOf')
  List<String>? get partOf => throw _privateConstructorUsedError;
  @JsonKey(name: 'hasTypes')
  List<String>? get hasTypes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordMeaningModelCopyWith<WordMeaningModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordMeaningModelCopyWith<$Res> {
  factory $WordMeaningModelCopyWith(
          WordMeaningModel value, $Res Function(WordMeaningModel) then) =
      _$WordMeaningModelCopyWithImpl<$Res, WordMeaningModel>;
  @useResult
  $Res call(
      {@JsonKey(name: 'definition') String? definition,
      @JsonKey(name: 'partOfSpeech') String? partOfSpeech,
      @JsonKey(name: 'synonyms') List<String>? synonyms,
      @JsonKey(name: 'antonyms') List<String>? antonyms,
      @JsonKey(name: 'typeOf') List<String>? typeOf,
      @JsonKey(name: 'derivation') List<String>? derivation,
      @JsonKey(name: 'pertainsTo') List<String>? pertainsTo,
      @JsonKey(name: 'regionOf') List<String>? regionOf,
      @JsonKey(name: 'inRegion') List<String>? inRegion,
      @JsonKey(name: 'hasUsages') List<String>? hasUsages,
      @JsonKey(name: 'hasCategories') List<String>? hasCategories,
      @JsonKey(name: 'inCategory') List<String>? inCategory,
      @JsonKey(name: 'hasSubstances') List<String>? hasSubstances,
      @JsonKey(name: 'substanceOf') List<String>? substanceOf,
      @JsonKey(name: 'hasMembers') List<String>? hasMembers,
      @JsonKey(name: 'memberOf') List<String>? memberOf,
      @JsonKey(name: 'entails') List<String>? entails,
      @JsonKey(name: 'also') List<String>? also,
      @JsonKey(name: 'similarTo') List<String>? similarTo,
      @JsonKey(name: 'hasInstances') List<String>? hasInstances,
      @JsonKey(name: 'instanceOf') List<String>? instanceOf,
      @JsonKey(name: 'hasParts') List<String>? hasParts,
      @JsonKey(name: 'partOf') List<String>? partOf,
      @JsonKey(name: 'hasTypes') List<String>? hasTypes});
}

/// @nodoc
class _$WordMeaningModelCopyWithImpl<$Res, $Val extends WordMeaningModel>
    implements $WordMeaningModelCopyWith<$Res> {
  _$WordMeaningModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? definition = freezed,
    Object? partOfSpeech = freezed,
    Object? synonyms = freezed,
    Object? antonyms = freezed,
    Object? typeOf = freezed,
    Object? derivation = freezed,
    Object? pertainsTo = freezed,
    Object? regionOf = freezed,
    Object? inRegion = freezed,
    Object? hasUsages = freezed,
    Object? hasCategories = freezed,
    Object? inCategory = freezed,
    Object? hasSubstances = freezed,
    Object? substanceOf = freezed,
    Object? hasMembers = freezed,
    Object? memberOf = freezed,
    Object? entails = freezed,
    Object? also = freezed,
    Object? similarTo = freezed,
    Object? hasInstances = freezed,
    Object? instanceOf = freezed,
    Object? hasParts = freezed,
    Object? partOf = freezed,
    Object? hasTypes = freezed,
  }) {
    return _then(_value.copyWith(
      definition: freezed == definition
          ? _value.definition
          : definition // ignore: cast_nullable_to_non_nullable
              as String?,
      partOfSpeech: freezed == partOfSpeech
          ? _value.partOfSpeech
          : partOfSpeech // ignore: cast_nullable_to_non_nullable
              as String?,
      synonyms: freezed == synonyms
          ? _value.synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      antonyms: freezed == antonyms
          ? _value.antonyms
          : antonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      typeOf: freezed == typeOf
          ? _value.typeOf
          : typeOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      derivation: freezed == derivation
          ? _value.derivation
          : derivation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      pertainsTo: freezed == pertainsTo
          ? _value.pertainsTo
          : pertainsTo // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      regionOf: freezed == regionOf
          ? _value.regionOf
          : regionOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inRegion: freezed == inRegion
          ? _value.inRegion
          : inRegion // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasUsages: freezed == hasUsages
          ? _value.hasUsages
          : hasUsages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasCategories: freezed == hasCategories
          ? _value.hasCategories
          : hasCategories // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inCategory: freezed == inCategory
          ? _value.inCategory
          : inCategory // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasSubstances: freezed == hasSubstances
          ? _value.hasSubstances
          : hasSubstances // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      substanceOf: freezed == substanceOf
          ? _value.substanceOf
          : substanceOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasMembers: freezed == hasMembers
          ? _value.hasMembers
          : hasMembers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      memberOf: freezed == memberOf
          ? _value.memberOf
          : memberOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      entails: freezed == entails
          ? _value.entails
          : entails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      also: freezed == also
          ? _value.also
          : also // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      similarTo: freezed == similarTo
          ? _value.similarTo
          : similarTo // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasInstances: freezed == hasInstances
          ? _value.hasInstances
          : hasInstances // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      instanceOf: freezed == instanceOf
          ? _value.instanceOf
          : instanceOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasParts: freezed == hasParts
          ? _value.hasParts
          : hasParts // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      partOf: freezed == partOf
          ? _value.partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasTypes: freezed == hasTypes
          ? _value.hasTypes
          : hasTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WordMeaningModelCopyWith<$Res>
    implements $WordMeaningModelCopyWith<$Res> {
  factory _$$_WordMeaningModelCopyWith(
          _$_WordMeaningModel value, $Res Function(_$_WordMeaningModel) then) =
      __$$_WordMeaningModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'definition') String? definition,
      @JsonKey(name: 'partOfSpeech') String? partOfSpeech,
      @JsonKey(name: 'synonyms') List<String>? synonyms,
      @JsonKey(name: 'antonyms') List<String>? antonyms,
      @JsonKey(name: 'typeOf') List<String>? typeOf,
      @JsonKey(name: 'derivation') List<String>? derivation,
      @JsonKey(name: 'pertainsTo') List<String>? pertainsTo,
      @JsonKey(name: 'regionOf') List<String>? regionOf,
      @JsonKey(name: 'inRegion') List<String>? inRegion,
      @JsonKey(name: 'hasUsages') List<String>? hasUsages,
      @JsonKey(name: 'hasCategories') List<String>? hasCategories,
      @JsonKey(name: 'inCategory') List<String>? inCategory,
      @JsonKey(name: 'hasSubstances') List<String>? hasSubstances,
      @JsonKey(name: 'substanceOf') List<String>? substanceOf,
      @JsonKey(name: 'hasMembers') List<String>? hasMembers,
      @JsonKey(name: 'memberOf') List<String>? memberOf,
      @JsonKey(name: 'entails') List<String>? entails,
      @JsonKey(name: 'also') List<String>? also,
      @JsonKey(name: 'similarTo') List<String>? similarTo,
      @JsonKey(name: 'hasInstances') List<String>? hasInstances,
      @JsonKey(name: 'instanceOf') List<String>? instanceOf,
      @JsonKey(name: 'hasParts') List<String>? hasParts,
      @JsonKey(name: 'partOf') List<String>? partOf,
      @JsonKey(name: 'hasTypes') List<String>? hasTypes});
}

/// @nodoc
class __$$_WordMeaningModelCopyWithImpl<$Res>
    extends _$WordMeaningModelCopyWithImpl<$Res, _$_WordMeaningModel>
    implements _$$_WordMeaningModelCopyWith<$Res> {
  __$$_WordMeaningModelCopyWithImpl(
      _$_WordMeaningModel _value, $Res Function(_$_WordMeaningModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? definition = freezed,
    Object? partOfSpeech = freezed,
    Object? synonyms = freezed,
    Object? antonyms = freezed,
    Object? typeOf = freezed,
    Object? derivation = freezed,
    Object? pertainsTo = freezed,
    Object? regionOf = freezed,
    Object? inRegion = freezed,
    Object? hasUsages = freezed,
    Object? hasCategories = freezed,
    Object? inCategory = freezed,
    Object? hasSubstances = freezed,
    Object? substanceOf = freezed,
    Object? hasMembers = freezed,
    Object? memberOf = freezed,
    Object? entails = freezed,
    Object? also = freezed,
    Object? similarTo = freezed,
    Object? hasInstances = freezed,
    Object? instanceOf = freezed,
    Object? hasParts = freezed,
    Object? partOf = freezed,
    Object? hasTypes = freezed,
  }) {
    return _then(_$_WordMeaningModel(
      definition: freezed == definition
          ? _value.definition
          : definition // ignore: cast_nullable_to_non_nullable
              as String?,
      partOfSpeech: freezed == partOfSpeech
          ? _value.partOfSpeech
          : partOfSpeech // ignore: cast_nullable_to_non_nullable
              as String?,
      synonyms: freezed == synonyms
          ? _value._synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      antonyms: freezed == antonyms
          ? _value._antonyms
          : antonyms // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      typeOf: freezed == typeOf
          ? _value._typeOf
          : typeOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      derivation: freezed == derivation
          ? _value._derivation
          : derivation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      pertainsTo: freezed == pertainsTo
          ? _value._pertainsTo
          : pertainsTo // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      regionOf: freezed == regionOf
          ? _value._regionOf
          : regionOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inRegion: freezed == inRegion
          ? _value._inRegion
          : inRegion // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasUsages: freezed == hasUsages
          ? _value._hasUsages
          : hasUsages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasCategories: freezed == hasCategories
          ? _value._hasCategories
          : hasCategories // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inCategory: freezed == inCategory
          ? _value._inCategory
          : inCategory // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasSubstances: freezed == hasSubstances
          ? _value._hasSubstances
          : hasSubstances // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      substanceOf: freezed == substanceOf
          ? _value._substanceOf
          : substanceOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasMembers: freezed == hasMembers
          ? _value._hasMembers
          : hasMembers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      memberOf: freezed == memberOf
          ? _value._memberOf
          : memberOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      entails: freezed == entails
          ? _value._entails
          : entails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      also: freezed == also
          ? _value._also
          : also // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      similarTo: freezed == similarTo
          ? _value._similarTo
          : similarTo // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasInstances: freezed == hasInstances
          ? _value._hasInstances
          : hasInstances // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      instanceOf: freezed == instanceOf
          ? _value._instanceOf
          : instanceOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasParts: freezed == hasParts
          ? _value._hasParts
          : hasParts // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      partOf: freezed == partOf
          ? _value._partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasTypes: freezed == hasTypes
          ? _value._hasTypes
          : hasTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WordMeaningModel implements _WordMeaningModel {
  const _$_WordMeaningModel(
      {@JsonKey(name: 'definition')
          required this.definition,
      @JsonKey(name: 'partOfSpeech')
          required this.partOfSpeech,
      @JsonKey(name: 'synonyms')
          required final List<String>? synonyms,
      @JsonKey(name: 'antonyms')
          required final List<String>? antonyms,
      @JsonKey(name: 'typeOf')
          required final List<String>? typeOf,
      @JsonKey(name: 'derivation')
          required final List<String>? derivation,
      @JsonKey(name: 'pertainsTo')
          required final List<String>? pertainsTo,
      @JsonKey(name: 'regionOf')
          required final List<String>? regionOf,
      @JsonKey(name: 'inRegion')
          required final List<String>? inRegion,
      @JsonKey(name: 'hasUsages')
          required final List<String>? hasUsages,
      @JsonKey(name: 'hasCategories')
          required final List<String>? hasCategories,
      @JsonKey(name: 'inCategory')
          required final List<String>? inCategory,
      @JsonKey(name: 'hasSubstances')
          required final List<String>? hasSubstances,
      @JsonKey(name: 'substanceOf')
          required final List<String>? substanceOf,
      @JsonKey(name: 'hasMembers')
          required final List<String>? hasMembers,
      @JsonKey(name: 'memberOf')
          required final List<String>? memberOf,
      @JsonKey(name: 'entails')
          required final List<String>? entails,
      @JsonKey(name: 'also')
          required final List<String>? also,
      @JsonKey(name: 'similarTo')
          required final List<String>? similarTo,
      @JsonKey(name: 'hasInstances')
          required final List<String>? hasInstances,
      @JsonKey(name: 'instanceOf')
          required final List<String>? instanceOf,
      @JsonKey(name: 'hasParts')
          required final List<String>? hasParts,
      @JsonKey(name: 'partOf')
          required final List<String>? partOf,
      @JsonKey(name: 'hasTypes')
          required final List<String>? hasTypes})
      : _synonyms = synonyms,
        _antonyms = antonyms,
        _typeOf = typeOf,
        _derivation = derivation,
        _pertainsTo = pertainsTo,
        _regionOf = regionOf,
        _inRegion = inRegion,
        _hasUsages = hasUsages,
        _hasCategories = hasCategories,
        _inCategory = inCategory,
        _hasSubstances = hasSubstances,
        _substanceOf = substanceOf,
        _hasMembers = hasMembers,
        _memberOf = memberOf,
        _entails = entails,
        _also = also,
        _similarTo = similarTo,
        _hasInstances = hasInstances,
        _instanceOf = instanceOf,
        _hasParts = hasParts,
        _partOf = partOf,
        _hasTypes = hasTypes;

  factory _$_WordMeaningModel.fromJson(Map<String, dynamic> json) =>
      _$$_WordMeaningModelFromJson(json);

  @override
  @JsonKey(name: 'definition')
  final String? definition;
  @override
  @JsonKey(name: 'partOfSpeech')
  final String? partOfSpeech;
  final List<String>? _synonyms;
  @override
  @JsonKey(name: 'synonyms')
  List<String>? get synonyms {
    final value = _synonyms;
    if (value == null) return null;
    if (_synonyms is EqualUnmodifiableListView) return _synonyms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _antonyms;
  @override
  @JsonKey(name: 'antonyms')
  List<String>? get antonyms {
    final value = _antonyms;
    if (value == null) return null;
    if (_antonyms is EqualUnmodifiableListView) return _antonyms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _typeOf;
  @override
  @JsonKey(name: 'typeOf')
  List<String>? get typeOf {
    final value = _typeOf;
    if (value == null) return null;
    if (_typeOf is EqualUnmodifiableListView) return _typeOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _derivation;
  @override
  @JsonKey(name: 'derivation')
  List<String>? get derivation {
    final value = _derivation;
    if (value == null) return null;
    if (_derivation is EqualUnmodifiableListView) return _derivation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _pertainsTo;
  @override
  @JsonKey(name: 'pertainsTo')
  List<String>? get pertainsTo {
    final value = _pertainsTo;
    if (value == null) return null;
    if (_pertainsTo is EqualUnmodifiableListView) return _pertainsTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _regionOf;
  @override
  @JsonKey(name: 'regionOf')
  List<String>? get regionOf {
    final value = _regionOf;
    if (value == null) return null;
    if (_regionOf is EqualUnmodifiableListView) return _regionOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _inRegion;
  @override
  @JsonKey(name: 'inRegion')
  List<String>? get inRegion {
    final value = _inRegion;
    if (value == null) return null;
    if (_inRegion is EqualUnmodifiableListView) return _inRegion;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasUsages;
  @override
  @JsonKey(name: 'hasUsages')
  List<String>? get hasUsages {
    final value = _hasUsages;
    if (value == null) return null;
    if (_hasUsages is EqualUnmodifiableListView) return _hasUsages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasCategories;
  @override
  @JsonKey(name: 'hasCategories')
  List<String>? get hasCategories {
    final value = _hasCategories;
    if (value == null) return null;
    if (_hasCategories is EqualUnmodifiableListView) return _hasCategories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _inCategory;
  @override
  @JsonKey(name: 'inCategory')
  List<String>? get inCategory {
    final value = _inCategory;
    if (value == null) return null;
    if (_inCategory is EqualUnmodifiableListView) return _inCategory;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasSubstances;
  @override
  @JsonKey(name: 'hasSubstances')
  List<String>? get hasSubstances {
    final value = _hasSubstances;
    if (value == null) return null;
    if (_hasSubstances is EqualUnmodifiableListView) return _hasSubstances;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _substanceOf;
  @override
  @JsonKey(name: 'substanceOf')
  List<String>? get substanceOf {
    final value = _substanceOf;
    if (value == null) return null;
    if (_substanceOf is EqualUnmodifiableListView) return _substanceOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasMembers;
  @override
  @JsonKey(name: 'hasMembers')
  List<String>? get hasMembers {
    final value = _hasMembers;
    if (value == null) return null;
    if (_hasMembers is EqualUnmodifiableListView) return _hasMembers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _memberOf;
  @override
  @JsonKey(name: 'memberOf')
  List<String>? get memberOf {
    final value = _memberOf;
    if (value == null) return null;
    if (_memberOf is EqualUnmodifiableListView) return _memberOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _entails;
  @override
  @JsonKey(name: 'entails')
  List<String>? get entails {
    final value = _entails;
    if (value == null) return null;
    if (_entails is EqualUnmodifiableListView) return _entails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _also;
  @override
  @JsonKey(name: 'also')
  List<String>? get also {
    final value = _also;
    if (value == null) return null;
    if (_also is EqualUnmodifiableListView) return _also;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _similarTo;
  @override
  @JsonKey(name: 'similarTo')
  List<String>? get similarTo {
    final value = _similarTo;
    if (value == null) return null;
    if (_similarTo is EqualUnmodifiableListView) return _similarTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasInstances;
  @override
  @JsonKey(name: 'hasInstances')
  List<String>? get hasInstances {
    final value = _hasInstances;
    if (value == null) return null;
    if (_hasInstances is EqualUnmodifiableListView) return _hasInstances;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _instanceOf;
  @override
  @JsonKey(name: 'instanceOf')
  List<String>? get instanceOf {
    final value = _instanceOf;
    if (value == null) return null;
    if (_instanceOf is EqualUnmodifiableListView) return _instanceOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasParts;
  @override
  @JsonKey(name: 'hasParts')
  List<String>? get hasParts {
    final value = _hasParts;
    if (value == null) return null;
    if (_hasParts is EqualUnmodifiableListView) return _hasParts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _partOf;
  @override
  @JsonKey(name: 'partOf')
  List<String>? get partOf {
    final value = _partOf;
    if (value == null) return null;
    if (_partOf is EqualUnmodifiableListView) return _partOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _hasTypes;
  @override
  @JsonKey(name: 'hasTypes')
  List<String>? get hasTypes {
    final value = _hasTypes;
    if (value == null) return null;
    if (_hasTypes is EqualUnmodifiableListView) return _hasTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'WordMeaningModel(definition: $definition, partOfSpeech: $partOfSpeech, synonyms: $synonyms, antonyms: $antonyms, typeOf: $typeOf, derivation: $derivation, pertainsTo: $pertainsTo, regionOf: $regionOf, inRegion: $inRegion, hasUsages: $hasUsages, hasCategories: $hasCategories, inCategory: $inCategory, hasSubstances: $hasSubstances, substanceOf: $substanceOf, hasMembers: $hasMembers, memberOf: $memberOf, entails: $entails, also: $also, similarTo: $similarTo, hasInstances: $hasInstances, instanceOf: $instanceOf, hasParts: $hasParts, partOf: $partOf, hasTypes: $hasTypes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WordMeaningModel &&
            (identical(other.definition, definition) ||
                other.definition == definition) &&
            (identical(other.partOfSpeech, partOfSpeech) ||
                other.partOfSpeech == partOfSpeech) &&
            const DeepCollectionEquality().equals(other._synonyms, _synonyms) &&
            const DeepCollectionEquality().equals(other._antonyms, _antonyms) &&
            const DeepCollectionEquality().equals(other._typeOf, _typeOf) &&
            const DeepCollectionEquality()
                .equals(other._derivation, _derivation) &&
            const DeepCollectionEquality()
                .equals(other._pertainsTo, _pertainsTo) &&
            const DeepCollectionEquality().equals(other._regionOf, _regionOf) &&
            const DeepCollectionEquality().equals(other._inRegion, _inRegion) &&
            const DeepCollectionEquality()
                .equals(other._hasUsages, _hasUsages) &&
            const DeepCollectionEquality()
                .equals(other._hasCategories, _hasCategories) &&
            const DeepCollectionEquality()
                .equals(other._inCategory, _inCategory) &&
            const DeepCollectionEquality()
                .equals(other._hasSubstances, _hasSubstances) &&
            const DeepCollectionEquality()
                .equals(other._substanceOf, _substanceOf) &&
            const DeepCollectionEquality()
                .equals(other._hasMembers, _hasMembers) &&
            const DeepCollectionEquality().equals(other._memberOf, _memberOf) &&
            const DeepCollectionEquality().equals(other._entails, _entails) &&
            const DeepCollectionEquality().equals(other._also, _also) &&
            const DeepCollectionEquality()
                .equals(other._similarTo, _similarTo) &&
            const DeepCollectionEquality()
                .equals(other._hasInstances, _hasInstances) &&
            const DeepCollectionEquality()
                .equals(other._instanceOf, _instanceOf) &&
            const DeepCollectionEquality().equals(other._hasParts, _hasParts) &&
            const DeepCollectionEquality().equals(other._partOf, _partOf) &&
            const DeepCollectionEquality().equals(other._hasTypes, _hasTypes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        definition,
        partOfSpeech,
        const DeepCollectionEquality().hash(_synonyms),
        const DeepCollectionEquality().hash(_antonyms),
        const DeepCollectionEquality().hash(_typeOf),
        const DeepCollectionEquality().hash(_derivation),
        const DeepCollectionEquality().hash(_pertainsTo),
        const DeepCollectionEquality().hash(_regionOf),
        const DeepCollectionEquality().hash(_inRegion),
        const DeepCollectionEquality().hash(_hasUsages),
        const DeepCollectionEquality().hash(_hasCategories),
        const DeepCollectionEquality().hash(_inCategory),
        const DeepCollectionEquality().hash(_hasSubstances),
        const DeepCollectionEquality().hash(_substanceOf),
        const DeepCollectionEquality().hash(_hasMembers),
        const DeepCollectionEquality().hash(_memberOf),
        const DeepCollectionEquality().hash(_entails),
        const DeepCollectionEquality().hash(_also),
        const DeepCollectionEquality().hash(_similarTo),
        const DeepCollectionEquality().hash(_hasInstances),
        const DeepCollectionEquality().hash(_instanceOf),
        const DeepCollectionEquality().hash(_hasParts),
        const DeepCollectionEquality().hash(_partOf),
        const DeepCollectionEquality().hash(_hasTypes)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WordMeaningModelCopyWith<_$_WordMeaningModel> get copyWith =>
      __$$_WordMeaningModelCopyWithImpl<_$_WordMeaningModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WordMeaningModelToJson(
      this,
    );
  }
}

abstract class _WordMeaningModel implements WordMeaningModel {
  const factory _WordMeaningModel(
      {@JsonKey(name: 'definition')
          required final String? definition,
      @JsonKey(name: 'partOfSpeech')
          required final String? partOfSpeech,
      @JsonKey(name: 'synonyms')
          required final List<String>? synonyms,
      @JsonKey(name: 'antonyms')
          required final List<String>? antonyms,
      @JsonKey(name: 'typeOf')
          required final List<String>? typeOf,
      @JsonKey(name: 'derivation')
          required final List<String>? derivation,
      @JsonKey(name: 'pertainsTo')
          required final List<String>? pertainsTo,
      @JsonKey(name: 'regionOf')
          required final List<String>? regionOf,
      @JsonKey(name: 'inRegion')
          required final List<String>? inRegion,
      @JsonKey(name: 'hasUsages')
          required final List<String>? hasUsages,
      @JsonKey(name: 'hasCategories')
          required final List<String>? hasCategories,
      @JsonKey(name: 'inCategory')
          required final List<String>? inCategory,
      @JsonKey(name: 'hasSubstances')
          required final List<String>? hasSubstances,
      @JsonKey(name: 'substanceOf')
          required final List<String>? substanceOf,
      @JsonKey(name: 'hasMembers')
          required final List<String>? hasMembers,
      @JsonKey(name: 'memberOf')
          required final List<String>? memberOf,
      @JsonKey(name: 'entails')
          required final List<String>? entails,
      @JsonKey(name: 'also')
          required final List<String>? also,
      @JsonKey(name: 'similarTo')
          required final List<String>? similarTo,
      @JsonKey(name: 'hasInstances')
          required final List<String>? hasInstances,
      @JsonKey(name: 'instanceOf')
          required final List<String>? instanceOf,
      @JsonKey(name: 'hasParts')
          required final List<String>? hasParts,
      @JsonKey(name: 'partOf')
          required final List<String>? partOf,
      @JsonKey(name: 'hasTypes')
          required final List<String>? hasTypes}) = _$_WordMeaningModel;

  factory _WordMeaningModel.fromJson(Map<String, dynamic> json) =
      _$_WordMeaningModel.fromJson;

  @override
  @JsonKey(name: 'definition')
  String? get definition;
  @override
  @JsonKey(name: 'partOfSpeech')
  String? get partOfSpeech;
  @override
  @JsonKey(name: 'synonyms')
  List<String>? get synonyms;
  @override
  @JsonKey(name: 'antonyms')
  List<String>? get antonyms;
  @override
  @JsonKey(name: 'typeOf')
  List<String>? get typeOf;
  @override
  @JsonKey(name: 'derivation')
  List<String>? get derivation;
  @override
  @JsonKey(name: 'pertainsTo')
  List<String>? get pertainsTo;
  @override
  @JsonKey(name: 'regionOf')
  List<String>? get regionOf;
  @override
  @JsonKey(name: 'inRegion')
  List<String>? get inRegion;
  @override
  @JsonKey(name: 'hasUsages')
  List<String>? get hasUsages;
  @override
  @JsonKey(name: 'hasCategories')
  List<String>? get hasCategories;
  @override
  @JsonKey(name: 'inCategory')
  List<String>? get inCategory;
  @override
  @JsonKey(name: 'hasSubstances')
  List<String>? get hasSubstances;
  @override
  @JsonKey(name: 'substanceOf')
  List<String>? get substanceOf;
  @override
  @JsonKey(name: 'hasMembers')
  List<String>? get hasMembers;
  @override
  @JsonKey(name: 'memberOf')
  List<String>? get memberOf;
  @override
  @JsonKey(name: 'entails')
  List<String>? get entails;
  @override
  @JsonKey(name: 'also')
  List<String>? get also;
  @override
  @JsonKey(name: 'similarTo')
  List<String>? get similarTo;
  @override
  @JsonKey(name: 'hasInstances')
  List<String>? get hasInstances;
  @override
  @JsonKey(name: 'instanceOf')
  List<String>? get instanceOf;
  @override
  @JsonKey(name: 'hasParts')
  List<String>? get hasParts;
  @override
  @JsonKey(name: 'partOf')
  List<String>? get partOf;
  @override
  @JsonKey(name: 'hasTypes')
  List<String>? get hasTypes;
  @override
  @JsonKey(ignore: true)
  _$$_WordMeaningModelCopyWith<_$_WordMeaningModel> get copyWith =>
      throw _privateConstructorUsedError;
}
